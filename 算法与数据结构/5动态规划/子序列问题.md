# 最长公共子序列
1. 准备
```C++
int lena,lenb;
string a,b;
vector<vector<int>>dp(lena+1,vector<int>(lenb+1));
```
2. 核心代码
```C++
for(int i=0;i<lena;i++){
    for(int j=0;j<lenb;j++){
        if(a[i]==b[j]){
            dp[i+1][j+1]=dp[i][j]+1;
        }
        else{
            dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]);
        }
    }
}
```
- 原理阐述：匹配则继承前面加一<br>
  不匹配则取上方或左侧的最优解，确保延续之前最优解<br>
  原因：取上方就是不要本位的a[i],取左侧就是不要b[j],延续最优解

# 最长上升子序列
1. 准备
```C++
int n;
vector<int>ans,num(n+1);
```
2. 核心代码
```C++
for(int x:num){
    // 使用二分查找找到第一个不小于当前元素的位置
    auto it=lower_bound(ans.begin(),ans.end(),x);
    if(it==ans.end()){//大于则所有扩充
        ans.push_back(x);
    }
    else{//将原有的替换为更小的
        *it=x;
    }
}
cout<<ans.size()<<'\n';
```
- 算法正确性证明：
1.维护 tails 的有序性
每次替换操作后，tails **仍然保持严格递增**，确保后续查找的正确性。

- 贪心策略的合理性
1.较小的末尾元素能为后续元素提供更多增长机会。<br>
2.**替换操作不改变当前子序列长度，但为未来可能更长的子序列创造条件**。
- 最长子序列长度的保证<br>
1.通过维护每个长度的最小末尾，tails 的长度最终等于最长递增子序列的长度。