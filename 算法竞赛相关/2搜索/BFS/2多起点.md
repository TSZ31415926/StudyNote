## 求出任意位置到离该位置最近（意为有多个）出口的最短路径且要求输出
1. 多起点BFS
2. BFS分层扩散

## 代码
```C++
//25.10 ABC D 多起点同时BFS （多起点同时BFS解决了两条路线相遇谁更优的问题，毕竟是同时BFS，都走了同样的步数谁比谁高贵？）
// 方向数组定义（注意顺序与ch数组的对应关系）
int dx[4] = {-1, 1, 0, 0};        // x方向移动：上、下、不动、不动
int dy[4] = {0, 0, -1, 1};        // y方向移动：不动、不动、左、右
int ch[4] = {'v', '^', '>', '<'}; // 对应方向字符：下箭头，上箭头，右箭头，左箭头
void solve()
{
    int n, m;
    cin >> n >> m;
    vector<vector<char>> mp(n + 1, vector<char>(m + 1)); // 创建(n+1)x(m+1)的网格
    queue<pair<int, int>> que; // BFS主队列（存储当前扩散层坐标）
    // 读取网格数据并初始化队列
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            cin >> mp[i][j];
            if (mp[i][j] == 'E')
            { // 找到所有出口'E'
                que.push({i, j});
            }
        }
    }
    // 分层BFS扩散过程
    do
    {
        queue<pair<int, int>> que2; // 临时队列存储下一层节点
        // 处理当前层的所有节点
        while (!que.empty())
        {
            auto fro = que.front();
            que.pop();
            // 遍历四个方向
            for (int i = 0; i < 4; i++)
            {
                int nx = fro.first + dx[i];
                int ny = fro.second + dy[i];

                // 边界检查与可扩散条件判断
                if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && mp[nx][ny] == '.')
                { // 只处理未标记的空单元格

                    mp[nx][ny] = ch[i];  // 标记扩散方向字符
                    que2.push({nx, ny}); // 加入下一层队列
                }
            }
        }
        que = que2; // 切换至下一层队列
    } while (!que.empty()); // 直到无法继续扩散为止
    // 输出处理后的网格
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            cout << mp[i][j];
        }
        cout << '\n';
    }
}
```