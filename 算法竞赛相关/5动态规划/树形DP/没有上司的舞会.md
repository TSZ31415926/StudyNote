```C++
#include <bits/stdc++.h>//25.5.28 洛谷1352
//核心思想：由下推上
#define endl '\n'               // 定义换行符
#define int long long           // 定义int为long long类型
using ull = unsigned long long; // 定义ull为无符号长整型
using namespace std;            // 使用标准命名空间
void solve()
{
    int n;
    cin >> n; // 输入员工数量（树节点数）
    // tree: 树的邻接表表示，tree[i]存储节点i的所有直接下属
    vector<vector<int>> tree(n + 1);
    // dp数组:
    // dp[i][0] - 不选择节点i时，以i为根的子树的最大快乐值
    // dp[i][1] - 选择节点i时，以i为根的子树的最大快乐值
    vector<vector<int>> dp(n + 1, vector<int>(2));
    vector<int> ind(n + 1); // 节点的入度（用于找根节点）
    // 读入每个节点的快乐值（作为选择该节点的初始值）
    for (int i = 1; i <= n; i++)
    {
        cin >> dp[i][1]; // dp[i][1]初始化为节点i的快乐值
    }
    // 构建树结构（n-1条边）
    for (int i = 1; i < n; i++)
    {
        int boss, em; // 注意输入顺序：先员工em，后上司boss
        cin >> em >> boss;
        ind[em]++;                // 员工em的入度+1（表示有上司）
        tree[boss].push_back(em); // 在树中添加从boss指向em的边
    }
    // 使用lambda表达式定义DFS函数（递归实现树形DP）
    auto dfs = [&](auto &&dfs, int root) -> void
    {
        // 遍历当前节点的所有直接下属
        for (int i = 0; i < tree[root].size(); i++)
        {
            int next = tree[root][i]; // 获取子节点
            dfs(dfs, next);           // 递归处理子树
            // 状态转移：
            // 1. 不选当前节点时，子节点可选可不选，取最大值累加
            dp[root][0] += max(dp[next][0], dp[next][1]);
            // 2. 选择当前节点时，子节点必须不选，直接累加dp[next][0]
            dp[root][1] += dp[next][0];
        }
    };
    // 寻找根节点（入度为0的节点）
    int root = 0;
    for (int i = 1; i <= n; i++)
    {
        if (!ind[i])
        { // 入度为0即为根节点
            root = i;
            break;
        }
    }
    // 从根节点开始DFS遍历
    dfs(dfs, root);
    // 输出结果：根节点选或不选的最大值
    cout << max(dp[root][0], dp[root][1]) << '\n';
    return;
}
signed main()
{
    ios::sync_with_stdio(false); // 关闭C与C++标准流的同步，加速输入输出
    cin.tie(0), cout.tie(0);     // 解除cin/cout与其它流的绑定，进一步加速
    int t = 1;
    // cin >> t; // 多组测试数据开关（当前被注释）
    while (t--)
    {
        solve(); // 调用求解函数
    }
    return 0;
}
```C++