## 核心代码
> \#define lowbit(x) ((x)&(-x))<br>
> 解释：用于求x的二进制形式最近的为1的位置所表示的数。如6=110&emsp;lowbit(6)=2

**在某处加x**
```C++
void add(int pos,int x){
    while(pos<=n){
        tree[pos]+=x;
        pos+=lowbit(pos);
    }
}
```
**计算前缀和**
```C++
int sum(int pos){
    int res=0;
    while(pos>0){
        res+=tree[pos];
        pos-=lowbit(pos);
    }
    return res;
}
```
**计算区间和**
>如l-r:int ans=sum(r)-sum(l-1);

## 拓展
### 用树状数组实现的差分数组
核心代码都是一样的，除了具体修改和查询有些思想上的不同<br>
如**初始化**操作：
```C++
// 初始化树状数组（使用差分数组技巧）
    update(1, num[1]); // 第一个元素直接更新
    // 后续元素：更新差分值（当前元素与前一个元素的差值）
    for (int i = 2; i <= n; i++)
    {
        update(i, num[i] - num[i - 1]); // 之所以要减是因为当使用树状数组来实现差分数组时，该操作相当于从i~n都加一个x，使用当前元素与前一个元素的差值就是为了实现真正的数组初始化
    }
```
**修改**操作：
```C++
// 区间更新：[l, r]区间增加x
    int l, r, x;
    cin >> l >> r >> x;
// 这里跟差分数组是一样的
//  差分数组核心操作：
    update(l, x);      // l位置增加x
    update(r + 1, -x); // r+1位置减少x（抵消超出区间的影响）
```
**查询**操作：
```C++
    // 单点查询：获取位置pos的值
    int pos;
    cin >> pos;
    // 注意：树状数组存储的是差分数组，sum(pos)就是原数组pos位置的值
    cout << sum(pos) << '\n'; // 直接输出前缀和
    // 就是为了这个单点查询才需要使用树状数组来实现
```
之间的**不同点**：
- 树状数组：单点更新 区间查询
- 用树状数组实现的差分数组：区间更新 单点查询
- 单纯差分数组：区间更新 单点查询 但是要等所有更新操作完成以后才可以