## 前言
详细解释待写
## 代码
```C++
#include <bits/stdc++.h>//洛谷1776 多重背包
using namespace std;
using ll = long long;

void solve()
{
    int n, w;
    cin >> n >> w; // 输入物品种类数n和背包容量w

    vector<int> val, wei; // 存储拆分后各物品块的价值和重量

    // 处理每个物品的二进制拆分
    for (int i = 0; i < n; ++i)
    {
        int v, wg, m;
        cin >> v >> wg >> m; // 读取物品的价值v、单件重量wg、最大数量m

        // 二进制拆分核心逻辑（将m分解为2的幂次组合）
        for (int k = 1; k <= m; k *= 2)
        {
            // 添加k个当前物品的组合：价值总和v*k，重量总和wg*k
            val.push_back(v * k);
            wei.push_back(wg * k);
            m -= k; // 扣除已处理的数量
        }
        // 处理剩余数量（当m不能被2的幂次完全分解时）
        if (m > 0)
        {
            val.push_back(v * m);  // 剩余m个物品的价值
            wei.push_back(wg * m); // 剩余m个物品的重量
        }
    }

    // 01背包动态规划处理
    vector<int> dp(w + 1, 0); // dp[j]表示容量为j时的最大价值
    for (int i = 0; i < val.size(); ++i)
    { // 遍历所有拆分后的物品块
        // 倒序遍历容量：确保每个物品块只被选取一次（01背包特性）
        for (int j = w; j >= wei[i]; --j)
        {
            // 状态转移：比较不拿当前物品和拿当前物品的情况
            dp[j] = max(dp[j], dp[j - wei[i]] + val[i]);
        }
    }

    cout << dp[w] << endl; // 输出最大容量w时的最优解
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr); // 加速输入输出
    solve();
    return 0;
}
```

## 01背包
输入后直接
```C++
vector<int> dp(w + 1, 0); // dp[j]表示容量为j时的最大价值
    for (int i = 0; i < val.size(); ++i)
    { // 遍历所有拆分后的物品块
        // 倒序遍历容量：确保每个物品块只被选取一次（01背包特性）
        for (int j = w; j >= wei[i]; --j)
        {
            // 状态转移：比较不拿当前物品和拿当前物品的情况
            dp[j] = max(dp[j], dp[j - wei[i]] + val[i]);
        }
    }
```
## 完全背包

没什么不同，j=0开始罢了（为了让其可以选择继承or本层选1/多选）
```C++
vector<int> dp(w + 1, 0); // dp[j]表示容量为j时的最大价值
    for (int i = 0; i < val.size(); ++i)
    { // 遍历所有拆分后的物品块
        for (int j = wei[i]; j <= w; --j)//w为背包容量
        {
            // 状态转移：比较不拿当前物品和拿当前物品的情况
            dp[j] = max(dp[j], dp[j - wei[i]] + val[i]);
        }
    }
```