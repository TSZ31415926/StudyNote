## 前言
详细解释待写
## 代码
- 通用准备工作
```C++
vector<int>val,wei;// 存储拆分后各物品块的 价值和重量  
vector<int> dp(w + 1, 0); // dp[j]表示容量为j时的最大价值
```
### 01背包
- **核心代码**
```C++
for(int i=0;i<val.size();i++){
    for(int j=ma;j>=wei[i];j--){
        // 倒序遍历容量：确保每个物品块只被选取一次（01背包特性）
        dp[j]=max(dp[j],dp[j-wei[i]]+val[i]);
        //dp[j-wei[i]]为空出空间后的解
    }
}
```
- 原理阐述：当处理物品i时，从j=w开始，遍历从第一件物品直到上一物品的dp[w~wei[i]]最优解，比较在花费相同空间j时，原答案最优还是空出空间拿本物品更优。
### 多重背包
- **核心dp代码与01背包无区别，但需要对物品先进行预处理**
```C++
for(int i=0;i<n;i++){
    int v,w,m;
    cin>>v>>w>>m;
    // 二进制拆分核心逻辑（将m分解为2的幂次组合）
    for(int k=1;k<=m;k*=2){// 添加k个当前物品的组合：价值总和v*k，重量总和w*k
        val.push_back(v*k);
        wei.push_back(w*k);
        m=m-k;
    }
    if(m>0){// 处理剩余数量（当m不能被2的幂次完全分解时）
        val.push_back(v*m);
        wei.push_back(w*m);
    }
}
```
- 原理阐述：将物品数m进行**二进制拆分**后，拆分后的部分**通过组合**可以变成0~m之间的**任意数**<br>如7->1,2,4(验证省略)，然后将各个部分**视作单一物品**，若0~m中有最优选择，那么在dp[j]遍历的过程中一定会选中，如若5最优，那么会选中1和4。

### 完全背包
- **没什么不同，j=wei[i]开始罢了（为了让其可以选择继承or本层选1/多选）**
```C++
for(int i=0;i<val.size();i++){
    for(int j=wei[i];j<=ma;j++){
        dp[j]=max(dp[j],dp[j-wei[i]]+val[i]);
    }
}
```
- 原理阐述：将j从wei[i]开始~ma，这样当后面j有条件拿多件该物品，**可以选择再拿一次**(就相当于任意件了)，毕竟没做限制，**前面的本物品最优可以被后面本物品最优所影响**。<br>那你可能会问，01背包j从ma开始~wei[i],过程中也会有j有条件拿多件的情况，那为什么结果跟完全背包不同？因为j是**从大到小**，**前面的本物品最优解不会被后面影响**。为什么？正如dp[6-3]怎么也影响不到dp[12-3]吧？