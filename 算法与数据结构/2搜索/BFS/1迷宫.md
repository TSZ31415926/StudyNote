## BFS走迷宫且要输出最短移动路径
不由得感慨拿走迷宫来试BFS真合适

## 代码
```C++
#include <bits/stdc++.h>
using namespace std;
#define int long long
void solve() {
    int n, m;
    cin >> n >> m;
    vector<vector<char>> mp(n+1, vector<char>(m+1));
    for (int i=1; i<=n; i++) {
        string s;
        cin >> s;
        for (int j=1; j<=m; j++) {
            mp[i][j] = s[j-1];
        }
    }
    // BFS队列：存储坐标(x,y)和当前路径
    queue<tuple<int, int, string>> q;
    q.push({1, 1, ""});
    vector<vector<bool>> visited(n+1, vector<bool>(m+1, false));
    visited[1][1] = true;
    // 方向：右(D), 下(S), 左(A), 上(W)（按字典序最小顺序）
    int dx[] = {0, 1, 0, -1};
    int dy[] = {1, 0, -1, 0};
    char dir[] = {'D', 'S', 'A', 'W'};
    while (!q.empty()) {
        auto [x, y, path] = q.front();
        q.pop();
        // 到达终点
        if (x == n && y == m) {
            cout << path << endl;
            return;
        }
        // 遍历四个方向
        for (int i=0; i<4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if (nx >=1 && nx <=n && ny >=1 && ny <=m && !visited[nx][ny] && mp[nx][ny] != '#') {
                visited[nx][ny] = true;
                q.push({nx, ny, path + dir[i]});//队列里的每一个元素都记录了从起点到这一步的独一无二的路径（有!visited[nx][ny]的作用）
            }
        }
    }
    // 无解
    cout << -1 << endl;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    solve();
    return 0;
}
```