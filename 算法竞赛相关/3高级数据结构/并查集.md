## 并查集思想的理解
并查集（Union-Find）的思想可以用一个非常生活化的比喻来理解：

**想象你是一个侦探，要管理一群江湖帮派。**

1. **初始化（每个人自成帮派）**  
   一开始，江湖上**每个人都是自己帮派的"老大"**。比如张三、李四、王五各自为政，每个人都是自己帮派的最高领导。
2. **查（Find）：找终极老大**  
   - 当你想知道两个人是否同属一个帮派时（比如查张三和李四是否一伙），就让他们各自"层层上报"找到自己的终极老大。
   - 如果两人的终极老大是同一个人，说明他们是一伙的；如果不是，说明属于不同帮派。
3. **并（Union）：帮派合并**  
   - 如果发现两个帮派其实是盟友（比如张三的帮派和李四的帮派），就让其中一个帮派的老大"认另一个帮派的老大做大哥"。
   - 比如让张三的老大认李四的老大当大哥，这样两个帮派就合并成一个了。

**优化技巧：**
- **路径压缩**：小弟直接记住总老大  
  每次查老大时，让途径的小弟直接记住终极老大（比如原本要经过二哥、大哥才能找到总老大，现在小弟直接记住总老大），下次查询更快。

- **按秩合并**：小帮派并入大帮派  
  合并时，让规模小的帮派认规模大的帮派当老大（避免树结构变得太高），提高查询效率。

**举个具体例子：**
- 开始：你（老大）、你朋友（老大）、你同学（老大）各自为政
- 合并：你和朋友成了朋友，你朋友的老大变成你
- 再合并：你同学和你成了朋友，你同学的老大变成你
- 查询：现在你、朋友、同学的老大都是你，说明你们是一伙的

**核心思想**：用树结构表示归属关系，通过不断优化树的深度，用接近O(1)的时间快速回答"是否同一组"和"合并组"这两个关键问题。就像现实中的"找靠山"和"认大哥"行为，最终形成一个高效的网络关系。
## 一个不错的模板
**关于初始化**
```C++
vector<int>f(n+1),high(n+1);
for(int i=1;i<=n;i++){
    f[i]=i;
    high[i]=1;
}
```
**查找操作**
```C++
int Find(int x)
{
    // 路径压缩：将x到根节点路径上的所有节点直接连接到根节点
    while (f[x] != x)
    {
        f[x] = f[f[x]]; // 将x的父节点指向祖父节点，压缩路径
        x = f[x];       // 继续向上查找
    }
    return x;
}
```

**合并操作**
```C++
void Union(int x, int y)
{
    int fx = Find(x); // 找到x的根节点
    int fy = Find(y); // 找到y的根节点
    // 如果两个节点不在同一个集合中才需要合并
    if (fx != fy)
    {
        // 总是将较小的树合并到较大的树中（按秩合并）
        if (high[fx] < high[fy])
            swap(fx, fy); // 保证fx总是较大的根
        f[fy] = fx;         // 将fy的父节点指向fx
        high[fx] += high[fy]; // 更新合并后的集合大小
    }
}
```
## 实战代码hdu1213
```C++
#include <bits/stdc++.h>
#define endl '\n'
using ll = long long;
using ull = unsigned long long;
using namespace std;
const ll MN = 1e6 + 1;
#if 0
#endif
int desk[1005], height[1005];
int find_set(int x){
    if(x!=desk[x]){
        desk[x] = find_set(desk[x]);
    }
    return desk[x];
}
void union_set(int x,int y){
    x = find_set(x);
    y = find_set(y);
    if(height[x]==height[y]){
        height[x]++;
        desk[y] = x;
    }
    else{
        if(height[x]<height[y]){
            desk[x] = y;
        }
        else{
            desk[y] = x;
        }
    }
}
void solve(){
    int per = 0, rel = 0;
    cin >> per>>rel;
    for (int i = 1; i <= per;i++){
        desk[i] = i;
        height[i] = 1;
    }
    int x, y;
    for (int i = 1; i <= rel;i++){
        cin >> x >> y;
        union_set(x, y);
    }
    int ans = 0;
    for (int i = 1; i <= per;i++){
        if(desk[i] == i){
            ans++;
        }
    }
    cout << ans << '\n';
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}
```
## 暂无