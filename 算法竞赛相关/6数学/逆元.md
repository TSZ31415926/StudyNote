## 逆元作用
- 用来高效求解组合数
- 用来应对包含模运算的除法

## 模板
1. 准备工作
   ```C++
   const int N = 1e6 + 5;
   const int mod = 998244353;
   int fact[N], inv_fact[N];//存储阶乘和逆元阶乘
   ```

2. 快速幂
   ```C++
   int q_pow(int a, int x)
   {
       int res = 1;
       while (x){
        if (x & 1)
            res = res * a % mod;
        a = a * a % mod;
        x >>= 1;
       }
       return res;
   }
   ```
3. 初始化阶乘和逆元阶乘
   ```C++
   void init_comb()
   {
    fact[0] = 1;
    //阶乘是从前递推
    for (int i = 1; i < N; ++i)
        fact[i] = fact[i - 1] * i % mod;

    //逆元阶乘从后递推，固要先求最后一个数的逆元阶乘（为该数x的fact[x]^mod-2）
    inv_fact[N - 1] = q_pow(fact[N - 1], mod - 2);
    for (int i = N - 2; i >= 0; --i)
        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod;
   }
   ```
4. 求解组合数
   ```C++
   int comb(int n, int k)
   {
    //注意特殊情况处理
    if (n < 0 || k < 0 || k > n)
        return 0;
    //原来：fact[n]/(fact[n-k]*fact[k] )
    //现在：fact[n]*inv_fact[n-k]*inv_fact[k]
    return fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod;
   }
   ```
5. 完整
```C++
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 5;
const int mod = 998244353;
int fact[N], inv_fact[N];
int q_pow(int a, int x){
    int res = 1;
    while (x){
    if (x & 1)
        res = res * a % mod;
        a = a * a % mod;
        x >>= 1;
    }
    return res;
}
void init_comb(){
    fact[0] = 1;
    for (int i = 1; i < N; ++i)
        fact[i] = fact[i - 1] * i % mod;
    inv_fact[N - 1] = q_pow(fact[N - 1], mod - 2);
    for (int i = N - 2; i >= 0; --i)
        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod;
}
int comb(int n, int k){
    if (n < 0 || k < 0 || k > n)
        return 0;
    return fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod;
}
signed main(){
    init_comb();
    int n,k;
    cin>>n>>k;
    cout<<comb(n,k)<<'\n';
}
```