## DFS走迷宫且要输出移动路径
&emsp;&emsp;DFS的本质是**先抓着一个点**不断往下探即不断向下递归。<br>&emsp;&emsp;十分要注意的是只有等这个点的结果已经明确了后才会换条路（即不会影响别的路）。依据这个特点，若要找正确路径并输出，只需要当能判断该条路经是正确时，直接return true，让上一步保存路径，然后上一步也返回return true让上上步保存路径，同时避免上步走另外一条路。
>**总之，核心就是理解dfs是抓一个点不断往下递归，直到到终点才会换一条路，且递归时不会影响别的路，若递归时做了修改，在该步走完后修复即可。**

### 代码
```C++
void solve()
{
    int n, m;
    cin >> n >> m;
    vector<vector<int>> mp(n + 1, vector<int>(m + 1));
    for (int i = 1; i <= n;i++){
        string s;
        cin >> s;
        for (int j = 1; j <= m;j++){
            mp[i][j] = s[j - 1];
        }
    }
    stack<char> ans;//存路径（递归由最后一步到最初，固用stack）
    int pan = 0;//记录是否有解
    auto dfs = [&](auto &&dfs, int x, int y) -> bool {
        if(x==n&&y==m){//到出口
            pan = 1;
            return true;
        }
        int nx = x;
        int ny = y + 1;
        if(mp[nx][ny]!='#'&&nx>=1&&nx<=n&&ny>=1&&ny<=m){//不是障碍且没越界
            if (dfs(dfs,nx,ny)){//存该步路径的必要条件是该步能通向出口
                ans.push('D');
                return true;//核心：直接return避免到下一步去
            }
        }
        nx = x + 1;
        ny = y;
        if (mp[nx][ny] != '#' && nx >= 1 && nx <= n && ny >= 1 && ny <= m)
        {
            if (dfs(dfs, nx, ny))
            {
                ans.push('S');
                return true;
            }
        }
        return false;
    };
    dfs(dfs, 1, 1);
    if(pan==0){
        cout << -1 << '\n';
        return;
    }
    while(!ans.empty()){
        cout << ans.top();
        ans.pop();
    }
    return;
}
```